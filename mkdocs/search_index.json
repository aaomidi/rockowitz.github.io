{
    "docs": [
        {
            "location": "/original_index/", 
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Default Index Page"
        }, 
        {
            "location": "/original_index/#welcome-to-mkdocs", 
            "text": "For full documentation visit  mkdocs.org .", 
            "title": "Welcome to MkDocs"
        }, 
        {
            "location": "/original_index/#commands", 
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.", 
            "title": "Commands"
        }, 
        {
            "location": "/original_index/#project-layout", 
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Project layout"
        }, 
        {
            "location": "/", 
            "text": "ddctool\n\n\nddctool is a program for querying and changing monitor settings, such as \nbrightness and color levels.   \n\n\nddctool uses DDC/CI to communicate with monitors implementing MCCS \n(Monitor Control Command Set) over I2C.  Normally, the video driver for the\nmonitor exposes the I2C channel as devices named /dev/i2c-n.  \n\n\nA particular use case for ddctool is as part of color profile management. Monitor\ncalibration is relative to the monitor color settings currently in effect, \ne.g. red gain.  ddctool allows color related settings to be saved at the time \na monitor is calibrated, and then restored when the calibration is applied.\n\n\nProviding Feedback\n\n\nBackground\n\n\nMonitor settings are referred to as Virtual Control Panel (VCP) features.\nFeatures are numbered from 0..255, and are specified using the hex\nrepresentation, e.g. 1A for blue level.   \n\n\nMCCS designates features as being one of three types:\n\n\n\n\nContinuous (C): Able to take any value up to some maximum\n\n\nNon-continuous (NC): Able to take only a designated set of values\n\n\nTable (T): Used for \"raw\" data such as a video LUT\n\n\n\n\nThis clean distinction has broken down as the MCCS specification has \nevolved.   Some features have changed category.  ddctool distinguishes\nbetween \"simple\" NC fields for which there is a simple list of possible values,\nand \"complex\" NC fields, where an algorithm must be applied to \ninterpret the bytes of a feature query.  This is a ddctool distinction and \nnot part of the MCCS specification.\n\n\nMost features are both readable and writable (RW).  Some, such as \nVCP Version (DF), are read-only (RO), while others, such as Restore\nFactory Defaults (02) are write-only.\n\n\nddctool Commands\n\n\n\n\n\n\n\n\nCommand\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\ndetect\n\n\nreport monitors detected\n\n\n\n\n\n\ncapabilities\n\n\nreport a monitor's capabilities string\n\n\n\n\n\n\nvcpinfo\n\n\nlist VCP features codes that ddctool knows how to interpret\n\n\n\n\n\n\ngetvcp feature-code-or-group\n\n\nreport a single VCP feature value, or a group of values\n\n\n\n\n\n\nsetvcp feature-code new-value\n\n\nset a single VCP feature value\n\n\n\n\n\n\ndumpvcp filename\n\n\nsave color related VCP feature values in a file\n\n\n\n\n\n\nloadvcp filename\n\n\nset color related VCP feature values from a file\n\n\n\n\n\n\nenvironment\n\n\nexplore the ddctool installation environment\n\n\n\n\n\n\ninterrogate\n\n\ncollect maximal information for problem diagnosis\n\n\n\n\n\n\n\n\nThere is an extensive set of options for tailoring ddctool operation. \nSome are described in this documentation.   For a full list, use the --help option or \nsee the man page:\n\n\nddctool --help\nman 1 ddctool\n\n\n\n\nMonitor Selection\n\n\nIf more than one monitor is attached, the desired monitor can be specified \nusing any of the following options:\n\n\n--display \ndisplay number\n\n--bus \ni2c bus number\n\n--adl \niAdapterNumber\n.\niDisplayNumber\n\n--edid \n256 character hex string\n\n--model \nmodel name\n and --sn \nserial number\n\n\n\n\n\nNotes:\n\n\n\n\nMonitors under control of AMD's proprietary driver (fglrx) are selected by\n  adapter number and display number. These numbers are specified on the --adl \n  option separated by a period, e.g. \"--adlno 1.0\"\n\n\nIf model and serial number are used to identify the monitor, both options \n  must be specified.\n\n\n\n\nTo see a list of all attached monitors and their associated identifiers:\n\n\nddctool detect\n\n\n\n\nInstrumentation and Tuning\n\n\nBuilding and Running ddctool\n\n\nBecause of the variation among distributions, only general guidelines can be \ngiven for some ddctool prerequisites.\n\n\nPackages\n\n\nddctool requires the following packages for both building and execution:\n\n\n\n\ni2c-tools\n\n\nglib-2.0  (Problem: glib-2.0 can be packaged with different names.)\n\n\n\n\nAt least on Ubuntu, the i2c.h header file is found in a separate package. \n\nIf the following package exists, it is required to build ddctool.\n\n\n\n\nlibi2c-dev \n\n\n\n\nNotes on building from tarball\n\n\nddctool\n can be built from its tarball in the usual way.  Unpack the tar file, change to its directory, and issue the commands: \n\n\n# ./configure\n# make\n# sudo make install\n\n\n\n\nNote that additional steps are required to build \nddctool\n with \nADL\n support.\nSee below.\n\n\nOther distribution formats, including \nrpm\n  \ndev\n files are not yet available.  \n\n\nNotes on building from git\n\n\n\n\nBuilding \nddctool\n from git requires that the \nautotools\n related packages be installed.\n\nThe exact packages vary from distribution to distribution.   On Ubuntu, these include:\n  -- autoconf\n  -- automake\n  -- autotools-dev\n  -- libtool\n  -- m4\n  -- pkg-config\n\n\n\n\nTo configure the build, change to the main \nddctool\n directory and execute the file: \n\n\nautogen.sh\n\n\n\n\nOr issue the individual commands: \n\n\n# aclocal\n# autoconf\n# automake\n# ./configure\n\n\n\n\nThen to build and install \nddctool\n: \n\n\n# make\n# sudo make install\n\n\n\n\nCommon issues:\n- Building with support for the AMD proprietary video driver (fglrx) requires that \nconfigure\n be executed using \nthe \n-with-adl-headers\n argument.  See below.\n- If you see a message \"required file './ltmain.sh.' not found\", run \nlibtoolize\n\n  (See https://www.gnu.org/software/automake/manual/html_node/Error-required-file-ltmain_002esh-not-found.html)\n- May get the following warning when running automake\n\n\nsrc/Makefile.am:38: warning: compiling 'cmdline/cmd_parser_aux.c' in subdir requires 'AM_PROG_CC_C_O' in 'configure.ac'\n\n\n\n\nThis is an autotools versioning issue.  It appears that this warning can be ignored.\n- (need notes on other warnings that can be ignored) \n\n\n/dev/i2c permissions\n\n\nExcept when using AMD's proprietary driver (see below) ddctool requires \nwrite access to /dev/i2c-*.  \n\n\nSome versions of i2c-tools create group i2c, and make that the group for \n/dev/i2c-* devices. In that case all that is necessary is to add your user\nname to group i2c: \n\n\n# sudo usermod your-user-name -G i2c\n\n\n\n\nFor testing, it may be simpler to give everyone permission to write to \n/dev/i2c-* for the current boot:\n\n\n#  sudo chmod a+rw /dev/i2c-*\n\n\n\n\nIf needed, a udev rule for giving group i2c rw permission on the /i2c-dev-* devices \ncan be found in distribution file data/etc/udev/rules.d/45-i2c-tools.rules. \n\nYou can copy this file to /etc/udev/rules.c. \n\n\nThe following section from the udev documentation \n(\nhttps://www.kernel.org/pub/linux/utils/kernel/hotplug/udev/udev.html\n) \nmay be helpful:\n\n\n\n\nThe udev rules are read from the files located in the system rules directory \n/usr/lib/udev/rules.d, the volatile runtime directory /run/udev/rules.d and \nthe local administration directory /etc/udev/rules.d. All rules files are \ncollectively sorted and processed in lexical order, regardless of the directories \nin which they live. However, files with identical file names replace each other. \nFiles in /etc have the highest priority, files in /run take precedence over files \nwith the same name in /lib. This can be used to override a system-supplied rules \nfile with a local file if needed; a symlink in /etc with the same name as a rules \nfile in /lib, pointing to /dev/null, disables the rules file entirely.\n\n\n\n\nKernel Modules\n\n\nIf using an open source driver, kernel module i2c-dev must be loaded.\n\nAdd the line \"i2c_dev\" to /etc/modules or a file containing the single line:\n\n\ni2c_dev\n\n\n\n\nto directory /etc/modules-load.d\n\n\n(TODO: Do instructions need to take into account SysV init vs systemd?)\n\n\nFrom the freedesktop.org systemd doc: \n\n\n\n\nsystemd-modules-load.service(8) reads files from the [following]directories\nwhich contain kernel modules to load during boot in a static list. \n\n\n/etc/modules-load.d/\n.conf\n/run/modules-load.d/\n.conf\n/usr.lib.modules-load.d/*.conf\n\n\nEach configuration file is named in the style of /etc/modules-load.d/program.conf. \nNote that it is usually a better idea to rely on the automatic module loading \nby PCI IDs, USB IDs, DMI IDs or similar triggers encoded in the kernel modules \nthemselves instead of static configuration like this. In fact, most modern \nkernel modules are prepared for automatic loading already.\n\n\n\n\nAMD fglrx Driver \n\n\nSpecial Nvidia driver settings\n\n\nWhen using Nvidia's proprietary driver, I2C communication fails on some cards.\nIt worked on several older Nvidia cards I have, but failed with my newer \nGTX660Ti. (Specfically, I2C reads of 1 or 2 bytes succeeded, but reads of 3 \nor more bytes failed.)  Others have reported similar problems. Adding the \nfollowing to the \"Device\" section for the Nvidia driver resolved the problem:\n\n\n Option     \nRegistryDwords\n  \nRMUseSwI2c=0x01; RMI2cSpeed=100\n\n\n\n\n\nA file for making this change is 90-nvidia_i2c.conf located in distribution \n directory data/etc/X11/xorg.conf.d  \n\n\nSection \nDevice\n\n   Driver \nnvidia\n\n   Identifier \nDev0\n\n   Option     \nRegistryDwords\n  \nRMUseSwI2c=0x01; RMI2cSpeed=100\n\n   # solves problem of i2c errors with nvidia driver\n   # per https://devtalk.nvidia.com/default/topic/572292/-solved-does-gddccontrol-work-for-anyone-here-nvidia-i2c-monitor-display-ddc/#4309293\nEndSection\n\n\n\n\nCopy this file to /etc/X11/xorg.conf.d  \n\n\nNote: This file works if there is no /etc/X11/xorg.conf file.  If you do have an \nxorg.conf file the Identifier field will likely require modification.\n\n\nVirtual Machines\n\n\nddctool can be built in a virtual machine.  However, loading i2_dev does \nnot create /dev/i2c-* devices, either on VirtualBox or VMware.  It's not \nclear whether this is because of lack of underlying emulation or if it's \na configuration issue.\n\n\nInstallation Diagnostics\n\n\nIf ddctool is successfully built but execution fails, command \nddctool environment\n \nprobes the I2C environment and may provide clues as to the problem.\n\n\nComparison with ddccontrol\n\n\nThe program ddccontrol appears to no longer be maintained.  It has a fragility \nreflecting the environment at the time it was written.  In particular:\n\n\n\n\nddcctontrol, at least some of the time, uses its own I2C driver code.\n\nddctool, on the other hand, relies exclusively on the the i2c-dev userspace \ninterface to i2c. (And also, ADL for fglrx).   This should make it less fragile.\n\n\nddccontrol uses a monitor attribute database to interpret VCP code.\n\nWith MCCS 2.0 and greater, VCP feature code definitions are largely standardized.\n\nddctool uses the MCCS specification to interpret VCP feature values.  It makes\nno attempt to interpret values for feature codes designated as manufacturer \nspecific (E0..FF). \n\n\n\n\nTo Do\n\n\nThis is a preliminary release.  There's an extensive TODO list\n\n\n\n\ninstallation without local build:\n-- downloadable tarball\n-- Ubuntu ppa, Fedora Copr, OpenSUSE build service\n\n\ncross-compile 32 bit executables on 64 bit systems\n\n\nwrite VCP Table type fields\n\n\ndocument the format of .VCP files (i.e. files read by \nddctool loadvcp\n)\n\n\nUI\n\n\npackage as library for use by other C programs, probably with gobject introsepection\n-- Python API\n\n\n\n\nAuthor\n\n\nSanford Rockowitz", 
            "title": "Overview"
        }, 
        {
            "location": "/#ddctool", 
            "text": "ddctool is a program for querying and changing monitor settings, such as \nbrightness and color levels.     ddctool uses DDC/CI to communicate with monitors implementing MCCS \n(Monitor Control Command Set) over I2C.  Normally, the video driver for the\nmonitor exposes the I2C channel as devices named /dev/i2c-n.    A particular use case for ddctool is as part of color profile management. Monitor\ncalibration is relative to the monitor color settings currently in effect, \ne.g. red gain.  ddctool allows color related settings to be saved at the time \na monitor is calibrated, and then restored when the calibration is applied.", 
            "title": "ddctool"
        }, 
        {
            "location": "/#providing-feedback", 
            "text": "", 
            "title": "Providing Feedback"
        }, 
        {
            "location": "/#background", 
            "text": "Monitor settings are referred to as Virtual Control Panel (VCP) features.\nFeatures are numbered from 0..255, and are specified using the hex\nrepresentation, e.g. 1A for blue level.     MCCS designates features as being one of three types:   Continuous (C): Able to take any value up to some maximum  Non-continuous (NC): Able to take only a designated set of values  Table (T): Used for \"raw\" data such as a video LUT   This clean distinction has broken down as the MCCS specification has \nevolved.   Some features have changed category.  ddctool distinguishes\nbetween \"simple\" NC fields for which there is a simple list of possible values,\nand \"complex\" NC fields, where an algorithm must be applied to \ninterpret the bytes of a feature query.  This is a ddctool distinction and \nnot part of the MCCS specification.  Most features are both readable and writable (RW).  Some, such as \nVCP Version (DF), are read-only (RO), while others, such as Restore\nFactory Defaults (02) are write-only.", 
            "title": "Background"
        }, 
        {
            "location": "/#ddctool-commands", 
            "text": "Command  Function      detect  report monitors detected    capabilities  report a monitor's capabilities string    vcpinfo  list VCP features codes that ddctool knows how to interpret    getvcp feature-code-or-group  report a single VCP feature value, or a group of values    setvcp feature-code new-value  set a single VCP feature value    dumpvcp filename  save color related VCP feature values in a file    loadvcp filename  set color related VCP feature values from a file    environment  explore the ddctool installation environment    interrogate  collect maximal information for problem diagnosis     There is an extensive set of options for tailoring ddctool operation. \nSome are described in this documentation.   For a full list, use the --help option or \nsee the man page:  ddctool --help\nman 1 ddctool", 
            "title": "ddctool Commands"
        }, 
        {
            "location": "/#monitor-selection", 
            "text": "If more than one monitor is attached, the desired monitor can be specified \nusing any of the following options:  --display  display number \n--bus  i2c bus number \n--adl  iAdapterNumber . iDisplayNumber \n--edid  256 character hex string \n--model  model name  and --sn  serial number   Notes:   Monitors under control of AMD's proprietary driver (fglrx) are selected by\n  adapter number and display number. These numbers are specified on the --adl \n  option separated by a period, e.g. \"--adlno 1.0\"  If model and serial number are used to identify the monitor, both options \n  must be specified.   To see a list of all attached monitors and their associated identifiers:  ddctool detect", 
            "title": "Monitor Selection"
        }, 
        {
            "location": "/#instrumentation-and-tuning", 
            "text": "", 
            "title": "Instrumentation and Tuning"
        }, 
        {
            "location": "/#building-and-running-ddctool", 
            "text": "Because of the variation among distributions, only general guidelines can be \ngiven for some ddctool prerequisites.", 
            "title": "Building and Running ddctool"
        }, 
        {
            "location": "/#packages", 
            "text": "ddctool requires the following packages for both building and execution:   i2c-tools  glib-2.0  (Problem: glib-2.0 can be packaged with different names.)   At least on Ubuntu, the i2c.h header file is found in a separate package.  \nIf the following package exists, it is required to build ddctool.   libi2c-dev", 
            "title": "Packages"
        }, 
        {
            "location": "/#notes-on-building-from-tarball", 
            "text": "ddctool  can be built from its tarball in the usual way.  Unpack the tar file, change to its directory, and issue the commands:   # ./configure\n# make\n# sudo make install  Note that additional steps are required to build  ddctool  with  ADL  support.\nSee below.  Other distribution formats, including  rpm    dev  files are not yet available.", 
            "title": "Notes on building from tarball"
        }, 
        {
            "location": "/#notes-on-building-from-git", 
            "text": "Building  ddctool  from git requires that the  autotools  related packages be installed. \nThe exact packages vary from distribution to distribution.   On Ubuntu, these include:\n  -- autoconf\n  -- automake\n  -- autotools-dev\n  -- libtool\n  -- m4\n  -- pkg-config   To configure the build, change to the main  ddctool  directory and execute the file:   autogen.sh  Or issue the individual commands:   # aclocal\n# autoconf\n# automake\n# ./configure  Then to build and install  ddctool :   # make\n# sudo make install  Common issues:\n- Building with support for the AMD proprietary video driver (fglrx) requires that  configure  be executed using \nthe  -with-adl-headers  argument.  See below.\n- If you see a message \"required file './ltmain.sh.' not found\", run  libtoolize \n  (See https://www.gnu.org/software/automake/manual/html_node/Error-required-file-ltmain_002esh-not-found.html)\n- May get the following warning when running automake  src/Makefile.am:38: warning: compiling 'cmdline/cmd_parser_aux.c' in subdir requires 'AM_PROG_CC_C_O' in 'configure.ac'  This is an autotools versioning issue.  It appears that this warning can be ignored.\n- (need notes on other warnings that can be ignored)", 
            "title": "Notes on building from git"
        }, 
        {
            "location": "/#devi2c-permissions", 
            "text": "Except when using AMD's proprietary driver (see below) ddctool requires \nwrite access to /dev/i2c-*.    Some versions of i2c-tools create group i2c, and make that the group for \n/dev/i2c-* devices. In that case all that is necessary is to add your user\nname to group i2c:   # sudo usermod your-user-name -G i2c  For testing, it may be simpler to give everyone permission to write to \n/dev/i2c-* for the current boot:  #  sudo chmod a+rw /dev/i2c-*  If needed, a udev rule for giving group i2c rw permission on the /i2c-dev-* devices \ncan be found in distribution file data/etc/udev/rules.d/45-i2c-tools.rules.  \nYou can copy this file to /etc/udev/rules.c.   The following section from the udev documentation \n( https://www.kernel.org/pub/linux/utils/kernel/hotplug/udev/udev.html ) \nmay be helpful:   The udev rules are read from the files located in the system rules directory \n/usr/lib/udev/rules.d, the volatile runtime directory /run/udev/rules.d and \nthe local administration directory /etc/udev/rules.d. All rules files are \ncollectively sorted and processed in lexical order, regardless of the directories \nin which they live. However, files with identical file names replace each other. \nFiles in /etc have the highest priority, files in /run take precedence over files \nwith the same name in /lib. This can be used to override a system-supplied rules \nfile with a local file if needed; a symlink in /etc with the same name as a rules \nfile in /lib, pointing to /dev/null, disables the rules file entirely.", 
            "title": "/dev/i2c permissions"
        }, 
        {
            "location": "/#kernel-modules", 
            "text": "If using an open source driver, kernel module i2c-dev must be loaded. \nAdd the line \"i2c_dev\" to /etc/modules or a file containing the single line:  i2c_dev  to directory /etc/modules-load.d  (TODO: Do instructions need to take into account SysV init vs systemd?)  From the freedesktop.org systemd doc:    systemd-modules-load.service(8) reads files from the [following]directories\nwhich contain kernel modules to load during boot in a static list.   /etc/modules-load.d/ .conf\n/run/modules-load.d/ .conf\n/usr.lib.modules-load.d/*.conf  Each configuration file is named in the style of /etc/modules-load.d/program.conf. \nNote that it is usually a better idea to rely on the automatic module loading \nby PCI IDs, USB IDs, DMI IDs or similar triggers encoded in the kernel modules \nthemselves instead of static configuration like this. In fact, most modern \nkernel modules are prepared for automatic loading already.", 
            "title": "Kernel Modules"
        }, 
        {
            "location": "/#amd-fglrx-driver", 
            "text": "", 
            "title": "AMD fglrx Driver"
        }, 
        {
            "location": "/#special-nvidia-driver-settings", 
            "text": "When using Nvidia's proprietary driver, I2C communication fails on some cards.\nIt worked on several older Nvidia cards I have, but failed with my newer \nGTX660Ti. (Specfically, I2C reads of 1 or 2 bytes succeeded, but reads of 3 \nor more bytes failed.)  Others have reported similar problems. Adding the \nfollowing to the \"Device\" section for the Nvidia driver resolved the problem:   Option      RegistryDwords    RMUseSwI2c=0x01; RMI2cSpeed=100   A file for making this change is 90-nvidia_i2c.conf located in distribution \n directory data/etc/X11/xorg.conf.d    Section  Device \n   Driver  nvidia \n   Identifier  Dev0 \n   Option      RegistryDwords    RMUseSwI2c=0x01; RMI2cSpeed=100 \n   # solves problem of i2c errors with nvidia driver\n   # per https://devtalk.nvidia.com/default/topic/572292/-solved-does-gddccontrol-work-for-anyone-here-nvidia-i2c-monitor-display-ddc/#4309293\nEndSection  Copy this file to /etc/X11/xorg.conf.d    Note: This file works if there is no /etc/X11/xorg.conf file.  If you do have an \nxorg.conf file the Identifier field will likely require modification.", 
            "title": "Special Nvidia driver settings"
        }, 
        {
            "location": "/#virtual-machines", 
            "text": "ddctool can be built in a virtual machine.  However, loading i2_dev does \nnot create /dev/i2c-* devices, either on VirtualBox or VMware.  It's not \nclear whether this is because of lack of underlying emulation or if it's \na configuration issue.", 
            "title": "Virtual Machines"
        }, 
        {
            "location": "/#installation-diagnostics", 
            "text": "If ddctool is successfully built but execution fails, command  ddctool environment  \nprobes the I2C environment and may provide clues as to the problem.", 
            "title": "Installation Diagnostics"
        }, 
        {
            "location": "/#comparison-with-ddccontrol", 
            "text": "The program ddccontrol appears to no longer be maintained.  It has a fragility \nreflecting the environment at the time it was written.  In particular:   ddcctontrol, at least some of the time, uses its own I2C driver code. \nddctool, on the other hand, relies exclusively on the the i2c-dev userspace \ninterface to i2c. (And also, ADL for fglrx).   This should make it less fragile.  ddccontrol uses a monitor attribute database to interpret VCP code. \nWith MCCS 2.0 and greater, VCP feature code definitions are largely standardized. \nddctool uses the MCCS specification to interpret VCP feature values.  It makes\nno attempt to interpret values for feature codes designated as manufacturer \nspecific (E0..FF).", 
            "title": "Comparison with ddccontrol"
        }, 
        {
            "location": "/#to-do", 
            "text": "This is a preliminary release.  There's an extensive TODO list   installation without local build:\n-- downloadable tarball\n-- Ubuntu ppa, Fedora Copr, OpenSUSE build service  cross-compile 32 bit executables on 64 bit systems  write VCP Table type fields  document the format of .VCP files (i.e. files read by  ddctool loadvcp )  UI  package as library for use by other C programs, probably with gobject introsepection\n-- Python API", 
            "title": "To Do"
        }, 
        {
            "location": "/#author", 
            "text": "Sanford Rockowitz", 
            "title": "Author"
        }, 
        {
            "location": "/download/", 
            "text": "openSUSE Build Service\n\n\nPackages for openSUSE, Fedora, and Debian are available for download from the \n\nopenSUSE build service\n\n\nUbuntu PPA\n\n\nFor \nUbuntu Wily\n\n\ndeb http://ppa.launchpad.net/rockowitz/ddctool/ubuntu wily main \ndeb-src http://ppa.launchpad.net/rockowitz/ddctool/ubuntu wily main \n\n\n\n\n\nTarball\n\n\n\n\n\nTarlocal", 
            "title": "Downloads"
        }, 
        {
            "location": "/download/#opensuse-build-service", 
            "text": "Packages for openSUSE, Fedora, and Debian are available for download from the  openSUSE build service", 
            "title": "openSUSE Build Service"
        }, 
        {
            "location": "/download/#ubuntu-ppa", 
            "text": "For  Ubuntu Wily  deb http://ppa.launchpad.net/rockowitz/ddctool/ubuntu wily main \ndeb-src http://ppa.launchpad.net/rockowitz/ddctool/ubuntu wily main", 
            "title": "Ubuntu PPA"
        }, 
        {
            "location": "/download/#tarball", 
            "text": "Tarlocal", 
            "title": "Tarball"
        }, 
        {
            "location": "/tuning/", 
            "text": "Instrumentation and Tuning\n\n\nI2C is an inherently unreliable protocol, requiring retry management.  90% of\nddctool's elapsed time is spent in timeouts mandated by the DDC specification.  \n\nddctool has extensive facilities for reporting protocol errors, retry counts, \nand peformance statistics, and some ability to tweak execution parameters from\nthe command line.\n\n\nThe relevant options are:\n\n\n\n\n\n\n\n\nOption\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\n--stats\n\n\nreport execution statistics\n\n\n\n\n\n\n--ddc\n\n\nreport DDC protocol errors\n\n\n\n\n\n\n--maxtries()\n\n\nsets maximum tries\n\n\n\n\n\n\n\n\nThere are 3 kinds of exchanges in which retry is possible: \n\n\n\n\nwrite-only exchange.  Bytes are written with no subsequent read.\n\n  Used only to set a VCP feature value.  \n\n\nwrite-read exchange.  A write to the monitor, followed by a read.\n\n  Most DDC protocol exchanges are of this form.\n\n\nmulti-part exchange.  This is a \"meta\" exchange, consisting multiple \n  write-read exchanges. Used to query monitor capabilities, and for \n  querying and setting Table type VCP features. \n\n\n\n\nBy default, the maximum number of tries for each exchange is:\n\n\n\n\nwrite-only exchange:    4\n\n\nwrite-read exchange:   10\n\n\nmulti-part exchange:    8\n\n\n\n\nOption --maxtries allows you to play with the maximum try count.  Its argument\nonsists of 3 comma-separated values.  The following example sets the maximum \ntry counts to 3 for write-only exchanges, 6 for write-read exchanges, and 9 \nfor multi-part exchanges.\n\n\n--maxtries(3,6,9) \n\n\n\n\nA blank value leaves the corresponding try count unchanged.   The following \nexample changes only the maximum write-read try count:\n\n\n--maxtries(,7,) \n\n\n\n\nThe maximum maximum value is 15.", 
            "title": "Instrumentation and Tuning"
        }, 
        {
            "location": "/tuning/#instrumentation-and-tuning", 
            "text": "I2C is an inherently unreliable protocol, requiring retry management.  90% of\nddctool's elapsed time is spent in timeouts mandated by the DDC specification.   \nddctool has extensive facilities for reporting protocol errors, retry counts, \nand peformance statistics, and some ability to tweak execution parameters from\nthe command line.  The relevant options are:     Option  Function      --stats  report execution statistics    --ddc  report DDC protocol errors    --maxtries()  sets maximum tries     There are 3 kinds of exchanges in which retry is possible:    write-only exchange.  Bytes are written with no subsequent read. \n  Used only to set a VCP feature value.    write-read exchange.  A write to the monitor, followed by a read. \n  Most DDC protocol exchanges are of this form.  multi-part exchange.  This is a \"meta\" exchange, consisting multiple \n  write-read exchanges. Used to query monitor capabilities, and for \n  querying and setting Table type VCP features.    By default, the maximum number of tries for each exchange is:   write-only exchange:    4  write-read exchange:   10  multi-part exchange:    8   Option --maxtries allows you to play with the maximum try count.  Its argument\nonsists of 3 comma-separated values.  The following example sets the maximum \ntry counts to 3 for write-only exchanges, 6 for write-read exchanges, and 9 \nfor multi-part exchanges.  --maxtries(3,6,9)   A blank value leaves the corresponding try count unchanged.   The following \nexample changes only the maximum write-read try count:  --maxtries(,7,)   The maximum maximum value is 15.", 
            "title": "Instrumentation and Tuning"
        }, 
        {
            "location": "/adl/", 
            "text": "Building with ADL support\n\n\nSpecial consideration is required if using AMD's proprietary driver (fglrx).\nThis driver does not expose /dev/i2c-* devices.  Instead, the driver provides\nI2C communication with the montior through its API, known as the AMD Device Library (ADL).\n\n\nThe ADL license does not allow its header files to be redistribution with the ddctool source. \n\nConsequently, extra steps are required to build a copy of ddctool that supports fglrx monitors: \n\n\n\n\nDownload the ADL SDK from \nhere\n.\n\n\nExtract the following files (they will be found in various subdirectories).\n\n  Copy them to some directory on your system: \n\n\n\n\n adl_defines.h\n adl_sdk.h\n adl_structures.h\n mccs.h\n\n\n\n\n\n\nWhen building ddctool from either the git source or tarball, execute configure as follows\n\n\n\n\n# ./configure --with-adl-headers=DIR\n\n\n\n\nwhere DIR is the name of the directory where you saved the ADL header files.\n\n\nNote: The license for the AMD Device Library (ADL) SDK library does allow for \nincorporating its components in distributed executables.  In the future, binaries \ndistributed from this site will be built with ADL support. That is not currently the case.", 
            "title": "AMD fglrx Driver"
        }, 
        {
            "location": "/adl/#building-with-adl-support", 
            "text": "Special consideration is required if using AMD's proprietary driver (fglrx).\nThis driver does not expose /dev/i2c-* devices.  Instead, the driver provides\nI2C communication with the montior through its API, known as the AMD Device Library (ADL).  The ADL license does not allow its header files to be redistribution with the ddctool source.  \nConsequently, extra steps are required to build a copy of ddctool that supports fglrx monitors:    Download the ADL SDK from  here .  Extract the following files (they will be found in various subdirectories). \n  Copy them to some directory on your system:     adl_defines.h\n adl_sdk.h\n adl_structures.h\n mccs.h   When building ddctool from either the git source or tarball, execute configure as follows   # ./configure --with-adl-headers=DIR  where DIR is the name of the directory where you saved the ADL header files.  Note: The license for the AMD Device Library (ADL) SDK library does allow for \nincorporating its components in distributed executables.  In the future, binaries \ndistributed from this site will be built with ADL support. That is not currently the case.", 
            "title": "Building with ADL support"
        }, 
        {
            "location": "/feedback/", 
            "text": "Feedback Needed\n\n\nThis is a preliminary release, and feedback would be very helpful. \n\nThere are a lot of \"moving parts\" that can vary from system to system: \n\n\n\n\nThe build environment can vary. \n\n\nI2C implementation can vary with card, monitor, and driver.\n\n  There is variation in MCCS interpretation.  \n\n\nI2C is an inherently unreliable protocol, requiring retry management.  \n\n\n\n\nIn particular: \n\n\n\n\nWere you able to build ddctool?\n\n  What changes were required to the Autoconf files?   \n\n\nDoes it work with given card, driver, and monitor?  I'm not particularly \n  concerned with older monitors whose MCCS version is unspecified (i.e. is \n  less than 2.0).  On the other hand, I'm very interested in how ddctool\n  handles monitors implementing MCCS V3.0, as the V3.0 specific code has not \n  been tested. In particular, does ddctool properly read Table type features? \n\n\nAnd of course, is the program useful?   Does it merit further development?\n\n  What features does it need?\n\n\n\n\nCommand \nddctool interrogate\n collects maximal information about the \ninstallation environment, video card and driver, and monitor capabilities. \n\nI'd appreciate it if you could redirect its output to a file and send the file\nto me. This will help diagnose problems and identify features that should be \nimplemented.", 
            "title": "Feedback Needed"
        }, 
        {
            "location": "/feedback/#feedback-needed", 
            "text": "This is a preliminary release, and feedback would be very helpful.  \nThere are a lot of \"moving parts\" that can vary from system to system:    The build environment can vary.   I2C implementation can vary with card, monitor, and driver. \n  There is variation in MCCS interpretation.    I2C is an inherently unreliable protocol, requiring retry management.     In particular:    Were you able to build ddctool? \n  What changes were required to the Autoconf files?     Does it work with given card, driver, and monitor?  I'm not particularly \n  concerned with older monitors whose MCCS version is unspecified (i.e. is \n  less than 2.0).  On the other hand, I'm very interested in how ddctool\n  handles monitors implementing MCCS V3.0, as the V3.0 specific code has not \n  been tested. In particular, does ddctool properly read Table type features?   And of course, is the program useful?   Does it merit further development? \n  What features does it need?   Command  ddctool interrogate  collects maximal information about the \ninstallation environment, video card and driver, and monitor capabilities.  \nI'd appreciate it if you could redirect its output to a file and send the file\nto me. This will help diagnose problems and identify features that should be \nimplemented.", 
            "title": "Feedback Needed"
        }
    ]
}